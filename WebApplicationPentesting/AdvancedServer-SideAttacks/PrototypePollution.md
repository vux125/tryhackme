
- Các class và Prototype trong JS là hai cách để đạt được một mục tiêu tương tự: tạo ra các đối tượng có hành vi và đặc điểm. Hãy tưởng tượng bạn đang xây dựng các mô hình ô tô trong phòng của mình. Sử dụng các lớp giống như có một bản thiết kế chi tiết hoặc một bộ hướng dẫn cho từng mẫu ô tô mà bạn muốn phát triển. Bạn làm theo bản thiết kế chính xác để tạo ra từng chiếc ô tô và tất cả các ô tô được tạo ra từ bản thiết kế chính xác đó đều được đảm bảo có cùng các tính năng và hành vi. Các lớp trong JavaScript hoạt động tương tự; chúng cung cấp một cách rõ ràng, có cấu trúc để tạo ra các đối tượng có cùng các thuộc tính và phương thức, giúp chúng dễ hiểu và dễ sử dụng.

- Mặt khác, các Prototype giống như việc có một mô hình xe cơ bản và sau đó tùy chỉnh nó bằng cách thêm hoặc sửa đổi các tính năng trực tiếp trên chính chiếc xe. Với các nguyên mẫu, bạn bắt đầu với một đối tượng đơn giản và sau đó thêm các hành vi vào đó bằng cách liên kết nó với một đối tượng nguyên mẫu đã có các hành vi đó. Các đối tượng được tạo theo cách này được liên kết thông qua chuỗi nguyên mẫu, cho phép chúng kế thừa các hành vi từ các đối tượng khác. Phương pháp này năng động và linh hoạt hơn nhưng có thể khó quản lý và hiểu hơn so với phương pháp tiếp cận có cấu trúc của các lớp.

- Bản thân Prototype Pollution không phải lúc nào cũng gây ra mối đe dọa có thể khai thác trực tiếp. Tuy nhiên, khả năng gây hại thực sự của nó trở nên rõ rệt khi kết hợp với các loại lỗ hổng khác, chẳng hạn như XSS và CSRF .

- Sẽ thế nào nếu kẻ tấn công chèn nội dung độc hại vào phương thức giới thiệu cho tất cả các trường hợp sử dụng __proto__. Trong JavaScript,thuộc tính __proto__ là cách phổ biến để truy cập nguyên mẫu của một đối tượng, về cơ bản là trỏ đến đối tượng mà nó kế thừa các thuộc tính và phương thức

![image](https://github.com/user-attachments/assets/09cb8c64-7b1f-4470-86e8-bfab3257b373)

# Khai thác XSS

## Phương pháp tiếp cận chuẩn

- Các thuộc tính constructor và __proto__ nổi bật là mục tiêu đặc biệt đáng chú ý để khai thác bởi các tác nhân đe dọa. Thuộc tính  constructortrỏ đến hàm xây dựng nguyên mẫu của đối tượng, trong khi __proto__ là tham chiếu đến đối tượng nguyên mẫu mà đối tượng hiện tại kế thừa trực tiếp từ đó.

## Quy tắc vàng

- Khái niệm này phụ thuộc vào khả năng của kẻ tấn công trong việc tác động đến một số tham số chính, chẳng hạn như x và val, trong các biểu thức tương tự như ***Person[x][y] = val***. Giả sử kẻ tấn công gán __proto__ cho x. Trong trường hợp đó, thuộc tính được xác định bởi yđược thiết lập chung trên tất cả các đối tượng chia sẻ cùng một lớp với đối tượng có giá trị được biểu thị bằng val.

## Một số chức năng quan trọng

- Khi xác định các lỗ hổng ô nhiễm nguyên mẫu tiềm ẩn, người kiểm tra thâm nhập nên tập trung vào các vectơ/chức năng thường dùng dễ bị ô nhiễm nguyên mẫu. Việc kiểm tra kỹ lưỡng cách ứng dụng xử lý thao tác đối tượng là rất quan trọng. Chúng ta sẽ hiểu một số chức năng quan trọng mà kẻ tấn công có thể khai thác, sau đó chúng ta sẽ thực hiện khai thác.

  -  Định nghĩa thuộc tính theo Đường dẫn : Các hàm thiết lập thuộc tính đối tượng dựa trên một đường dẫn nhất định (như object[a][b][c] = value) có thể nguy hiểm nếu các thành phần đường dẫn được kiểm soát bởi đầu vào của người dùng. Các hàm này cần được kiểm tra để đảm bảo chúng không vô tình sửa đổi nguyên mẫu của đối tượng.  Hãy xem xét một điểm cuối cho phép người dùng cập nhật đánh giá về bất kỳ người bạn nào.

# Khai thác Property Injection

## Few Important Functions

- Object Recursive Merge : Hàm này liên quan đến việc hợp nhất đệ quy các thuộc tính từ các đối tượng nguồn vào một đối tượng mục tiêu. Kẻ tấn công có thể khai thác chức năng này nếu hàm hợp nhất không xác thực các đầu vào của nó và cho phép hợp nhất các thuộc tính vào chuỗi nguyên mẫu. Xem xét cùng một ví dụ về mạng xã hội, hãy giả sử đoạn mã sau. Giả sử ứng dụng có một hàm để hợp nhất các thiết lập của người dùng:

![image](https://github.com/user-attachments/assets/bb57c4f2-8d7f-4813-9ea6-e50ae9933aac)

- Object Clone: Bản sao đối tượng là một chức năng tương tự cho phép các hoạt động sao chép sâu sao chép các thuộc tính từ chuỗi nguyên mẫu sang một chuỗi khác một cách vô tình. Kiểm thử phải đảm bảo rằng các hàm này chỉ sao chép các thuộc tính do người dùng xác định của một đối tượng và lọc các từ khóa đặc biệt như __proto__, constructor, v.v. Một trường hợp sử dụng khả thi là ứng dụng phụ trợ sao chép các đối tượng để tạo hồ sơ người dùng mới

# Khai thác Denial of Service

## DoS

- Ô nhiễm nguyên mẫu, một lỗ hổng nghiêm trọng trong các ứng dụng JavaScript, có thể dẫn đến một cuộc tấn công Từ chối dịch vụ ( DoS ), cùng với các hậu quả nghiêm trọng khác. Điều này xảy ra khi kẻ tấn công thao túng nguyên mẫu của một đối tượng được sử dụng rộng rãi, khiến ứng dụng hoạt động bất ngờ hoặc bị sập hoàn toàn. Trong JavaScript, các đối tượng kế thừa các thuộc tính và phương thức từ nguyên mẫu của chúng và việc thay đổi nguyên mẫu này sẽ ảnh hưởng đến tất cả các đối tượng chia sẻ nó.

- Ví dụ, nếu kẻ tấn công làm ô nhiễm phương thức Object.prototype.toString , mọi lệnh gọi tiếp theo đến phương thức này của bất kỳ đối tượng nào sẽ thực hiện hành vi đã thay đổi. Trong một ứng dụng phức tạp toStringthường xuyên được sử dụng, điều này có thể dẫn đến kết quả không mong muốn, có khả năng khiến ứng dụng bị trục trặc. toStringPhương thức này được sử dụng rộng rãi trong JavaScript. Nó được tự động gọi trong nhiều ngữ cảnh, đặc biệt là khi một đối tượng cần được chuyển đổi thành chuỗi.

- Nếu phương pháp bị ô nhiễm dẫn đến xử lý không hiệu quả hoặc vòng lặp vô hạn, nó có thể làm cạn kiệt tài nguyên hệ thống, gây ra tình trạng DoS. Hơn nữa, ô nhiễm nguyên mẫu cũng có thể can thiệp vào logic kinh doanh của ứng dụng. Việc thay đổi các phương pháp hoặc thuộc tính thiết yếu có thể kích hoạt các ngoại lệ hoặc lỗi không được xử lý, dẫn đến việc chấm dứt các quy trình hoặc dịch vụ. Điều này có thể khiến máy chủ không phản hồi trong các ứng dụng web, từ chối dịch vụ cho người dùng hợp pháp.

# Tự động hóa quá trình

- Xác định ô nhiễm nguyên mẫu là một vấn đề khó khăn trong bất kỳ ngôn ngữ nào, đặc biệt là trong JavaScript, vì cách JavaScript cho phép một tự động hóa nguyên mẫu ô nhiễmđối tượng chia sẻ các tính năng của nó với đối tượng khác. Phát hiện vấn đề này tự động bằng các công cụ phần mềm thực sự khó khăn vì nó không đơn giản như các vấn đề bảo mật trang web phổ biến khác. Mỗi trang web hoặc ứng dụng web đều khác nhau và việc tìm ra nơi ô nhiễm nguyên mẫu có thể xảy ra đòi hỏi ai đó phải xem xét kỹ mã của trang web, hiểu cách thức hoạt động của nó và xem lỗi có thể xảy ra ở đâu.

- Không giống như các vấn đề bảo mật khác có thể được tìm thấy bằng cách tìm kiếm các mẫu hoặc dấu hiệu cụ thể, việc tìm ra ô nhiễm nguyên mẫu cần phải đào sâu vào mã của trang web bởi một pentester/nhà phát triển. Tất cả là về việc hiểu các cách phức tạp mà các đối tượng trong JavaScript có thể ảnh hưởng lẫn nhau và phát hiện ra nơi có thể xảy ra sự cố. Các công cụ bảo mật có thể giúp chỉ ra các vấn đề có thể xảy ra, nhưng chúng không thể phát hiện ra mọi thứ. Đó là lý do tại sao việc có những người biết cách đọc và phân tích mã cẩn thận lại quan trọng đến vậy.

- Một số tool hữu ích:

    - NodeJsScan: là trình quét mã bảo mật tĩnh cho các ứng dụng Node.js. Nó bao gồm các kiểm tra cho nhiều lỗ hổng bảo mật khác nhau, bao gồm cả ô nhiễm nguyên mẫu. Tích hợp NodeJsScan vào quy trình phát triển của bạn có thể giúp tự động xác định các vấn đề bảo mật tiềm ẩn trong cơ sở mã của bạn.
 
    - Prototype Pollution Scanner: là một công cụ được thiết kế để quét mã JavaScript để tìm lỗ hổng bảo mật nguyên mẫu. Công cụ này có thể được sử dụng để phân tích các cơ sở mã để tìm ra các mẫu dễ bị ô nhiễm, giúp các nhà phát triển xác định và giải quyết các vấn đề bảo mật tiềm ẩn trong ứng dụng của họ.
 
    - PPFuzz: là một fuzzer khác được thiết kế để tự động hóa quá trình phát hiện lỗ hổng ô nhiễm nguyên mẫu trong các ứng dụng web. Bằng cách làm mờ các vectơ đầu vào có thể tương tác với các thuộc tính đối tượng,PPFuzzcó thể giúp xác định các điểm trong ứng dụng dễ bị ô nhiễm nguyên mẫu.
 
    - Phát hiện phía máy khách của BlackFan tập trung vào việc xác định các lỗ hổng ô nhiễm nguyên mẫu trong JavaScript phía máy khách. Nó bao gồm các ví dụ về cách ô nhiễm nguyên mẫu có thể bị khai thác trong trình duyệt để thực hiện các cuộc tấn công XSS và các hoạt động độc hại khác. Đây là một nguồn tài nguyên có giá trị để hiểu tác động của ô nhiễm nguyên mẫu ở phía máy khách.

# Biện pháp giảm thiểu

- Pentesters:

  - Input Fuzzing and Manipulation
 
  - Context Analysis and Payload Injection
 
  - CSP Bypass and Payload Injection

  - Dependency Analysis and Exploitation

  - Static Code Analysis

- Secure Code Developers

  - Avoid Using __proto__
 
  - Immutable Objects
 
  - Encapsulation
 
  - Use Safe Defaults
 
  - Input Sanitisation
 
  - Dependency Management
 
  - Security Headers

